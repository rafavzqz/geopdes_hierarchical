function I = get_active_cells(indices, hmsh, hspace, E)
%
% function I = get_active_cells(indices, hmsh, hspace, E)
%
% Computation of the indices of the active cells within the support of a
% B-spline function in the hierarchical basis.
%
% Input:
%           indices: indices of the B-spline basis functions 
%
% Ouput:
%           I: matrix whose rows contains the indices of the cells in the
%           support of the given B-spline
%
% WARNING: We are assuming open knot vectors with multiplicity 1 at
% interior nodes (We generalize this function later...)
%
% Mejorar el siguiente procedimiento
%

if nargin == 3
    Ne = cumsum([0; hmsh.nel_per_level(:)]);
E = cell(hmsh.nlevels,1);
% El siguiente loop seguramente se puede evitar usando mat2cell
for lev = 1:hmsh.nlevels
    ind_e = (Ne(lev)+1):Ne(lev+1); 
    E{lev} = hmsh.globnum_active(ind_e, 2:end);
end
end


nfun = numel(indices);
I = cell(nfun,1);

for ii = indices

    lev = hspace.globnum_active(ii,1);
    ind = hspace.globnum_active(ii,2:end);
    nelem = hmsh.mesh_of_level(lev).nel_dir;

II = get_cells(ind, hspace.degree, nelem);

cuales = ismember(II, E{lev},'rows');

I{ii} = [lev*ones(sum(cuales),1) II(cuales,:)];

YY = II(~cuales,:); % YY non active cells of level lev
ny = size(YY,1);

while ny
    II = [];
    for i = 1:ny
        II = vertcat(II, split_cell(YY(i,:)));
    end
    lev = lev + 1;
    if lev > msh.nlevels
        disp('ERROR: get_active_cells');
    end
    cuales = ismember(II, E{lev},'rows');
    I = vertcat(I, [lev*ones(sum(cuales),1) II(cuales,:)]);
    YY = II(~cuales,:); % YY non active cells of level lev
    ny = size(YY,1);
end


