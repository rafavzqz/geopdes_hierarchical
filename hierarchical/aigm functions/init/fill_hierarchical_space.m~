function [hmsh, hspace] = tp2hier (msh, space, geometry, boundary)
%
% function [hmsh, hspace] = tp2hier (msh, space, geometry, boundary)
%
% This function initializes the structures hmsh and hpsace from the
% tensor-product mesh and space. For the initialization of the mesh, the
% function tp2hier_msh is used.
%
% INPUT
%           msh: the coarsest mesh (level 1)
%           space: the spline space for the coarsest space (level 1)
%           geometry: 
%           boundary: true or false, default: true. (Fill the information for the boundaries).
%
% OUTPUT
%           hmsh: see tp2hier_msh
%           hspace: structure for the hierarchical space. It contains the following.
%
% FIELD_NAME     SIZE                         DESCRIPTION
% ndim           (scalar)           number of parametric directions
% degree        (1 x ndim array)    polynomial degree in each parametric direction
% ndof          (scalar)           total number of active functions 
% nlevels       (scalar)           the number of levels
% space_of_level (1 x nlevels)                tensor product space of each level, with 1d evaluations on the mesh of the same level (see sp_bspline)
% Proj           (hmsh.nlevels-1 x ndim cell-array) the coefficients relating 1D splines of two consecutive levels
%     Proj{l,i} is a matrix of size N_{l+1} x N_l where N_l is the number of univariate functions of level l in the direction l, such that
% A function B_{k,l} = \sum_j c^k_j B_{j,l+1}, and c_j = Proj{l,i}(j,k)
% globnum_active (ndof x (ndim+1))  global tensor-product numbering of active functions and their corresponding level
% ndof_per_level (1 x nlevels array) number of active functions on each level
% active        (1 x nlevels cell-array) List of active functions on each level
% coeff         (ndof x 1)         coefficientes to form the partition of the unity in the hierarchical space
% removed       (1 x nlevels cell-array) List of removed functions on each level
% C             (1 x hmsh.nlevels cell-array) Matrices for changing basis (see compute_matrices_for_changing_basis.m)
% sp_lev        (hmsh.nlevels x 1 cell-array) sp_lev{ilev} is a structure
%

if nargin == 3
    boundary = true;
end

hmsh = tp2hier_msh (msh, geometry, boundary);

hspace.ndim = hmsh.ndim;
hspace.degree = space.degree;
hspace.ncomp = space.ncomp;

hspace.nlevels = 1;
hspace.ndof = space.ndof;
hspace.active{1} = 1:space.ndof;

aux = cell(hspace.ndim,1);
[aux{:}] = ind2sub(space.ndof_dir,1:space.ndof);
hspace.globnum_active = [ones(space.ndof,1) cell2mat(aux)'];

hspace.ndof_per_level = [space.ndof];
hspace.coeff = ones(space.ndof,1);    
hspace.removed{1} = zeros(0,hspace.ndim);  
hspace.space_of_level = space;
hspace.Proj = [];
hspace.C{1} = speye(space.ndof);
hspace.sp_lev{1} = sp_evaluate_element_list (hspace.space_of_level(1), hmsh.msh_lev{1}, 'gradient', true,'hessian', true);


if (boundary && hmsh.ndim > 1)
    for iside = 1:2*hmsh.ndim
        hspace.boundary(iside) = init_hierarchical_mesh(msh.boundary(iside), geometry.boundary(iside), false);
    end
else
    hmsh.boundary = [];
end