function hspace = tp2hier_space (hmsh, space, boundary)
%
% function hspace = tp2hier_space (hmsh, space, boundary)
%
% This function initializes a struct hspace from the tensor product space
% and the hierarchical mesh hmsh already initializated with tp2hier_msh
%
% INPUT
%                       hmsh: see tp2hier_msh
%                       space: the spline space for the coarsest space (level 1)
%                       boundary: true or false, default: true. (Fill the information for the boundaries of the mesh).
% OUPUT
%                       struct hmsh (Hierarchical mesh)
% 
%               FIELD_NAME    TYPE               DESCRIPTION
%               ndim           (scalar)          number of parametric directions
%               rdim           (scalar)
%               nlevels       (scalar)           the number of levels
%               nsub          (1 x ndim array)           number of subdivisions on each level
%               mesh_of_level (1 x nlevels mesh) Cartesian mesh of each level (see msh_cartesian)
%               nel           (scalar)           total number of active cells  
%               nel_per_level (1 x nlevels array) number of active cells on each level
%               globnum_active (nel x (dim+1))  global tensor-product numbering of active cells and their corresponding level
%               active        (1 x nlevels cell-array) List of active elements on each level
%               removed       (1 x nlevels cell-array) List of removed cells on each level
%               msh_lev     (nlevels x 1 cell-array) msh_lev{ilev} is a structure
%               geometry
%               boundary    
%

hspace.ndim = hmsh.ndim;
hspace.degree = space.degree;
hspace.ncomp = space.ncomp;

hspace.nlevels = 1;
hspace.ndof = space.ndof;
hspace.active{1} = 1:space.ndof;

aux = cell(hspace.ndim,1);
[aux{:}] = ind2sub(space.ndof_dir,1:space.ndof);
hspace.globnum_active = [ones(space.ndof,1) cell2mat(aux)'];

hspace.ndof_per_level = [space.ndof];
hspace.coeff = ones(space.ndof,1);    
hspace.removed{1} = zeros(0,hspace.ndim);  
hspace.space_of_level = space;
hspace.Proj = [];
hspace.C{1} = speye(space.ndof);
hspace.sp_lev{1} = sp_evaluate_element_list (hspace.space_of_level(1), hmsh.msh_lev{1}, 'gradient', true,'hessian', true);


if (boundary && hmsh.ndim > 1)
    for iside = 1:2*hmsh.ndim
        %%    ind =[2 3; 2 3; 1 3; 1 3; 1 2; 1 2] in 3D, %ind = [2 2 1 1] in 2D;
        ind = setdiff (1:hmsh.ndim, ceil(iside/2));
        i = setdiff (1:hmsh.ndim, ind);
        if mod(iside,2) == 1
            boundary_ind = 1;
        else
            boundary_ind = hspace.space_of_level(1).ndof_dir(i);
        end
        boundary = tp2hier_space (hmsh.boundary(iside), space.boundary(iside), false);
        
        % Now, we fill hspace.boundary(iside).dofs
       % globnum_active_boundary = [hspace.boundary(iside).globnum_active(:,1:i) boundary_ind*ones(hspace.boundary(iside).ndof,1) ...
         %   hspace.boundary(iside).globnum_active(:,(i+1):end)];          
        globnum_active_boundary = [boundary.globnum_active(:,1:i) boundary_ind*ones(boundary.ndof,1) ...
            boundary.globnum_active(:,(i+1):end)];    
        [unos, boundadofs] = ismember(globnum_active_boundary,hspace.globnum_active,'rows');
        boundary.dofs = dofs;
        hspace.boundary(iside) = boundary;
        if any(unos~=1)
            disp('Warning: Error when computing hspace.boundary().dofs')
            pause
        end
    end
else
    hspace.boundary = [];
end