\documentclass[a4paper]{siamltex1213}

%\usepackage[notref,notcite]{showkeys}
%\usepackage{latexsym,amsfonts,amssymb,amsthm,amsmath,amscd,eufrak,makeidx}
%\usepackage{fullpage}
\usepackage[dvips]{graphicx}
%\usepackage{psfrag}
\usepackage{amsmath}
\usepackage{fancybox}
\usepackage{amsfonts}
%\usepackage{amsthm}
\usepackage{amssymb}
%\usepackage{comment}
%\usepackage{cancel}
\usepackage{color}
%\usepackage[]{algorithm2e}
\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage{bm}
%\usepackage{xspace}
%\usepackage[english]{babel}
%\usepackage{authblk}

%\usepackage[normalem]{ulem} % to be able to use \sout

%\usepackage{enumerate}
%\usepackage{pdfsync}

%% \usepackage[%
%% %   pdftex=true,  % si se usa pdftex
%% %   pdfpagemode=UseNone,
%% %   pdfstartpage=3,   % para empezar en pag. 3
%%    bookmarks=true,
%% %   bookmarksopen=true,
%% %   bookmarksnumbered=true,
%% %   plainpages=false, % cuando existe p\'agina i y p\'agina 1
%% %   pdfstartview=XYZ,
%% %   pdfpagelabels=true, % ii en preambulo
%%    pagebackref=false, % referencias a citas
%%    colorlinks,
%%    linkcolor=blue,
%% %   linktocpage, % link en el n\'umero de pagina en toc
%%    anchorcolor=blue,
%%    citecolor=blue,
%%    filecolor=blue,
%%    %pagecolor=blue,
%%    urlcolor=blue
%%    ]{hyperref}



% \theoremstyle{plain}
%    \newtheorem{theorem}{Theorem}[section]
%    \newtheorem{corollary}[theorem]{Corollary}
%    \newtheorem{lemma}[theorem]{Lemma}
%    \newtheorem{proposition}[theorem]{Proposition}
    \newtheorem{assumption}[theorem]{Assumption}
% \theoremstyle{definition}
%    \newtheorem{definition}[theorem]{Definition}
    \newtheorem{remark}[theorem]{Remark}
% \theoremstyle{remark}
  %  \newtheorem{notation}[theorem]{Notation}
    \newtheorem{example}[theorem]{Example}
 
% \newcommand{\Proof}{\noindent\emph{Proof.}\xspace}


% Para el \fint %%%%%%%
%\usepackage{txfonts}
%\newcommand{\fint}{\int}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%% Paquetes adicionales (sacar despues) %%%%%%%%%%%%%%%
% hyperref
%----------------------------------------------

% definicion de \algoritmo
\newcounter{contadoralgoritmo}
\setcounter{contadoralgoritmo}{0}
\newcommand{\algoritmo}[2]{
\medskip
\begin{center}
\doublebox{ % otras opciones: doublebox, ovalbox, Ovalbox
\begin{minipage}{.95\textwidth}
\refstepcounter{contadoralgoritmo}
\noindent\textbf{ALGORITHM \arabic{contadoralgoritmo}: #1 }
\tt

#2
\end{minipage}
}
\end{center}

}

\newcommand{\Rd}{\color{red}}
\renewcommand{\Rd}{\color{black}}

% %%%%%%%% DEFINITION OF MACROS
\newcommand{\note}[1]{{\noindent\centerline{\fbox{\parbox{.9\textwidth}{\textbf{
#1}}}}}}
\newcommand{\bluenote}[1]{{\color{blue}\noindent\centerline{\fbox{\parbox{.9\textwidth}{\textbf{
#1}}}}}}

% %\newcommand{\note}[1]{}
 \newcommand{\snote}[1]{\fbox{\textbf{#1}}}
 %\newcommand{\snote}[1]{}

 \DeclareMathOperator*{\infimum}{inf\phantom{p}\!\!\!}
 \newcommand{\infsup}[2]{\infimum_{#1}\sup_{#2}}


\newcommand{\step}[1]{\noindent\raisebox{1.5pt}[10pt][0pt]{\tiny\framebox{$#1$}}
\xspace}
\newcommand{\D}{\displaystyle}


%\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\diam}{diam}
\DeclareMathOperator{\Div}{div}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\loc}{loc}
\DeclareMathOperator{\trunc}{trunc}

\newcommand{\bnew}[1]{{\color{blue}{#1}}}
%\newcommand{\bnew}[1]{#1}
\newcommand{\rdel}[1]{{\color{red}{\sout{#1}}}}
%\newcommand{\rdel}[1]{}

\newcommand{\activeelements}[1]{\tt E^A_{#1}}
\newcommand{\deactelements}[1]{\tt E^D_{#1}}
\newcommand{\activefunctions}[1]{\tt F^A_{#1}}
\newcommand{\deactfunctions}[1]{\tt F^D_{#1}}

\DeclareMathOperator\mesh{\texttt{MESH}}
\DeclareMathOperator\basis{\texttt{SPACE}}
\DeclareMathOperator\removed{\tt R}
\DeclareMathOperator\marked{\tt MARKED}
\DeclareMathOperator\newcells{\tt NE}
%\DeclareMathOperator\activeelements{\tt E^A}
%\DeclareMathOperator\deactelements{\tt E^D}
\DeclareMathOperator\markedelements{\tt ME}
%\DeclareMathOperator\activefunctions{\tt F^A}
%\DeclareMathOperator\deactfunctions{\tt F^D}
\DeclareMathOperator\functionstoremove{\tt MF}
\newcommand\qih{\Pi}
\newcommand\qihh{\breve{\Pi}}
\newcommand\NN{\mathbb N}
%\newcommand\UU{\mathcal U}
\newcommand\AAA{\mathcal A}
\newcommand\BB{\mathcal B}

\newcommand\MM{\mathcal M}
\newcommand\Tau{\mathcal T}
\newcommand\PP{\mathbb P}
\newcommand\QQ{\mathcal Q}
\newcommand\HH{\mathcal H}
\newcommand\TT{\mathcal T}
\newcommand\VV{\mathcal S}
\newcommand\WW{\mathbb W}
\newcommand\EE{\mathcal E}
\newcommand\RRR{\mathcal R}
\newcommand\SSS{\mathbb S}
\newcommand\CC{\mathcal C}
\newcommand\NNN{\mathcal N}
\newcommand\PPP{\mathcal P}
\newcommand{\JJ}{\mathcal J}
\newcommand{\RR}{\mathbb R}
%\newcommand{\nref}{n}
\newcommand{\h}{h}

\newcommand{\NT}{{\mathcal N}_\Tau}

\newcommand{\etal}{et.~al.}

\newcommand{\norm}[1]{{\left\vert\kern-0.25ex\left\vert\kern-0.25ex\left\vert #1  \right\vert\kern-0.25ex\right\vert\kern-0.25ex\right\vert}}

\newcommand{\bx}{{\bf x}}


\let\hat\widehat
\let\tilde\widetilde

\title{Algorithms for local refinement \\ in hierarchical spline spaces. {\Rd UPDATE}}

\author{Eduardo M.~Garau\footnotemark[1]\ \footnotemark[2]\ \and Rafael V\'azquez\footnotemark[3]}

\begin{document}
\maketitle

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\footnotetext[1]{Instituto de Matem\'atica Aplicada del Litoral (CONICET-UNL), Argentina}
\footnotetext[2]{Facultad de Ingenier\'ia Qu\'imica (UNL), Argentina}
\footnotetext[3]{Istituto di Matematica Applicata e Tecnologie Informatiche `E. Magenes' (CNR), Italy}
\renewcommand{\thefootnote}{\arabic{footnote}}

% 
% \begin{abstract}
%  
% \end{abstract}
% 
% \begin{quote}\small
% \textbf{Keywords:} % adaptivity in isogemetric analysis, hierarchical B-splines, \snote{...}
% \end{quote}
% 
% \begin{quote}\small
%  \textbf{Mathematics Subject Classification (2000):}
% 35J15,  % Second-order elliptic equations
% 65N12, % Stability and convergence of numerical methods
% 65N15, % Error bounds
% 65N30, % Finite elements, Rayleigh-Ritz and Galerkin methods, finite methods
% 65N50, % Mesh generation and refinement
% 65Y20  % Complexity and performance of numerical algorithms 
% \end{quote}

{\Rd We have to decide about the levels. From 0 to $n$, and $n$ is empty, or from $1$ to $n+1$, and $n+1$ is empty. The first is C, the second is Matlab, Fortran.}

Por que el indice de nivel es un subindice, y no un superindice? Por mi no hay problema...

\section{Introduction}
\cite{Scott2014222,Bornemann2013584}, \cite{KGJ14}?

\section{Setting and mathematical definitions}
As it is standard in isogeometric analysis, we consider a domain $\Omega \subset \RR^r$ which is defined as the image of the unit domain $\hat \Omega = (0,1)^d$, with $d \le r$, through a given (rational) spline parametrization. One can think that the parametrization is defined with tensor product B-splines or NURBS, more details in the case of hierarchical splines will be given below.

\subsection{Underlying sequence of tensor product spline spaces} \label{sec:B-splines}
We consider a given sequence $\{\VV_\ell\}_{\ell \in\NN_0}$ of tensor-product $d$-variate spline spaces such that
\begin{equation}\label{E:tensor-product spaces}
 \VV_0\subset \VV_1\subset \VV_2\subset\VV_3\subset\dots,
\end{equation}
which are determined by their degree and their knot vectors. 
For $\ell\in\NN_0$, the B-spline basis corresponding to $\VV_\ell$ is denoted by $\BB_\ell$, and the dimension of the space is $N_\ell$. Furthermore, we denote by $\QQ_\ell$ the Cartesian mesh associated to $\BB_\ell$, and we say that $Q\in\QQ_\ell$ is a \emph{cell of level $\ell$}.

B-splines possess several important properties, that we do not list here, that make them suitable for design and analysis, see \cite{DeBoor, Schumi,IGA-book} for details. We will make extensive use in this work of the \emph{two-scale relation}, which consists in writing B-splines of level $\ell$ as linear combinations of B-splines of level $\ell+1$. More precisely, 
\begin{equation} \label{E:two scale relation}
 \beta_{i,\ell} = \sum_{k=1}^{N_{\ell+1}}
c_{k,\ell+1}(\beta_{i,\ell}) \, \beta_{k,\ell+1}, 
\qquad \forall\,\beta_{i,\ell} \in\BB_\ell.
\end{equation}
The two-scale relation is a direct consequence of the nestedness of the spaces. Moreover, due to the local linear independence of B-splines, only a limited number of the coefficients $c_{k,\ell+1}(\beta_{i,\ell})$ are different from zero. We will say that $\beta_{k,\ell+1}$ is a \emph{child} of $\beta_{i,\ell}$ if $c_{k,\ell+1}(\beta_{i,\ell}) \ne 0$, and denote by $\CC(\beta_{i,\ell})\subset\BB_{\ell+1}$ the set of children of $\beta_{i,\ell}$.

Considering the two-scale relation for each basis function, we obtain an operator $C_\ell^{\ell+1}: \VV_\ell \longrightarrow \VV_{\ell+1}$, which can be written in matrix form, {\Rd with entries $(C_\ell^{\ell+1})_{ki} = c_{k,\ell+1}(\beta_{i,\ell})$.} For tensor product B-splines, the matrix is computed as the Kronecker tensor product of the analogous matrices corresponding to the univariate case.

Successively applying the two-scale relation, we obtain the general version
\begin{equation*}
 \beta_{i,\ell} = \sum_{k=1}^{N_{\ell+m}}
c_{k,\ell+m}(\beta_{i,\ell})\beta_{k,\ell+m}, 
\qquad \forall\,\beta_{i,\ell} \in\BB_\ell,
\end{equation*}
and the matrix operator $C_\ell^{\ell+m} = C_{\ell+m-1}^{\ell+m} \ldots C_{\ell+1}^{\ell+2} C_\ell^{\ell+1}$, which relates functions of non-consecutive levels.

\subsection{Hierarchical B-splines}
For the definition of hierarchical B-splines we {\Rd essentially follow \cite{Kraft,Vuong_giannelli_juttler_simeon}}. 

\begin{definition} \label{def:hierarchical}
We consider a sequence of spaces like \eqref{E:tensor-product spaces}, and for some $n \in \NN$ we say that ${\bf\Omega}_n := \{\Omega_0,\Omega_1,\dots,\Omega_n\}$ is a hierarchy of subdomains of depth $n$ if
\begin{equation*}
\hat \Omega = \Omega_0 \supset \Omega_1 \supset \dots \supset 
\Omega_{n-1}\supset \Omega_n = \emptyset,
\end{equation*}
and (the closure of) each subdomain $\Omega_\ell$ is (the closure of) the union of cells of level $\ell-1$.

We define the hierarchical B-spline basis ${\HH} \equiv {\HH}({\bf\Omega}_n)$ by taking $\HH = \HH_{n-1}$ in the following recursive algorithm
%\begin{equation}\label{E:Hierarchical basis}
%{\HH}= \bigcup_{\ell = 0}^{n-1} \{\beta \in \BB_\ell \mid (\supp \beta 
%\subset \Omega_\ell) \wedge (\supp \beta \not\subset \Omega_{\ell+1})\}.
%\end{equation} 
\begin{equation}\label{E:Hierarchical basis}
\left \{
\begin{array}{l}
\HH_0 := \BB_0, \\
\HH_{\ell+1} := \{\beta \in \HH_\ell \mid \supp \beta \not \subset \Omega_{\ell+1} \} \cup \{\beta \in \BB_{\ell+1} \mid \supp \beta \subset \Omega_{\ell+1}\}.
\end{array}
\right.
\end{equation} 

\end{definition}
The hierarchical spline basis is associated to an underlying \emph{hierarchical mesh} $\QQ \equiv \QQ({\bf\Omega}_n)$, given by
\begin{equation}\label{E:hierarchical mesh}
\QQ:= \bigcup_{\ell = 0}^{n-1} \{ Q\in\QQ_\ell\,\mid\, Q\subset \Omega_\ell 
\,\wedge\, Q\not\subset \Omega_{\ell+1}\}.
\end{equation}
In the following we say that $Q$ is an \emph{active cell} if $Q \in \QQ$, and it is an \emph{active cell of level $\ell$} if $Q \in \QQ_\ell \cap \QQ$. We will also say that $Q$ is a \emph{deactivated cell of level $\ell$} if $Q \in \QQ_\ell$ and $Q \subset \Omega_{\ell+1}$. 

Analogously, we say that $\beta$ is an \emph{active (basis) function} if $\beta\in\HH$, it is an \emph{active function of level $\ell$} if $\beta \in \HH \cap \BB_\ell$, and it is a \emph{deactivated function of level $\ell$} if $\beta \in \HH_\ell \setminus \HH_{\ell+1}$. Moreover, $\HH_\ell \cap \BB_\ell$ is the union of active and deactivated functions of level $\ell$. Note that a function of level $\ell$ is active if all the active cells within its support are of level $\ell$ or higher, and at least one cell of level $\ell$ is active. A function is deactivated when all the cells of its level within the support have been deactivated.
{\Rd ADD FIGURE?}

It will be helpful, specially to write things in matrix form, to give a notation for the number of these functions. We will denote by $N= \# \HH$ the dimension of the hierarchical space, and by $N^A_\ell$ and $N^D_\ell$ the number of active and deactivated functions of level $\ell$, respectively. Sometimes we will also make use of {\Rd $N^A_\ell = \sum_{k=0}^\ell N_k^A$}, that is, the number of active functions up to level $\ell$.


Finally, we remark that, unlike in the tensor product case, the basis functions of the hierarchical space do not form a partition of unity, although the unity belongs to the space. That is, there exist coefficients $a_\beta$ such that 
 \begin{equation}\label{E:partition of the unity in the hierarchical space}
\sum_{\beta\in {\HH}} a_\beta \beta (\bx) = 1, \qquad\text{for } \bx \in \hat \Omega,
\end{equation}
and it can be proved that $a_\beta \ge 0$. 


\subsection{A {\Rd Simplified} hierarchical B-spline space}
In \cite{BG15} the authors introduced a different hierarchical space, with the same approximation properties as the one in the previous section but with lower dimension. This new space is defined in a way that focus on the relation between functions. 

\begin{definition}
Given a sequence of spaces as in \eqref{E:tensor-product spaces} and a hierarchy of subdomains as in Definition~\ref{def:hierarchical}, we define the {\Rd simplified} hierarchical basis $\tilde \HH = \tilde \HH_{n-1}$ computed with the following recursive algorithm:
\begin{equation}\label{E:Hierarchical basis2}
\left \{
\begin{array}{l}
\tilde \HH_0 := \BB_0, \\
\displaystyle \tilde \HH_{\ell+1} := \{\beta \in \tilde \HH_\ell \mid \supp \beta \not \subset \Omega_{\ell+1} \} \cup \bigcup_{\substack{\beta \in \tilde \HH_\ell \\ \supp \beta \subset \Omega_{\ell+1}}} \CC(\beta).
\end{array}
\right.
\end{equation} 
\end{definition}
Unlike in the classical definition, where the decision for activating a function is based on its support, therefore checking whether the cells in its support are active, in this new space functions of level $\ell+1$ become active only if they are children of a deactivated function of level $\ell$. This may lead to simpler refinement schemes, specially for a posteriori estimators which are based on the basis functions and not on the elements \cite{BG15b}.

Notice that the underlying hierarchical mesh is the same for both spaces. Moreover, the evaluation of the basis functions will be done exactly in the same way. From a practical point of view, the only difference between the spaces is the computation of the set of active functions during refinement.

An interesting property of the new defined space is that now the coefficients for writing the unity are strictly positive. That is, we have 
 \begin{equation*}\label{E:partition of the unity in the hierarchical space}
\sum_{\beta\in {\tilde \HH}} a_\beta \beta (\bx) = 1, \qquad\text{for } \bx \in \hat \Omega,
\end{equation*}
with $a_\beta > 0$. 

\subsection{Truncated hierarchical B-splines} \label{sec:truncated}
Truncated hierarchical B-splines (THB-splines) were introduced and analysed in \cite{Giannelli2012485, GJS14}. THB-splines represent an alternative basis for the space of hierarchical splines, that recovers the partition of unity and reduces the support of the basis functions, therefore reducing the interaction between them. In particular, this leads to sparser and better conditioned matrices in isogeometric analysis. Moreover, the better properties of THB-splines with respect to the standard basis make them more appropriate to develop the mathematical theory of approximation and adaptivity \cite{MS15,BGi15}.

The definition of THB-splines requires first the definition of the truncation operator. This consists in removing in the two-scale relation the contribution of active and deactivated functions of the next level, that we recall to be the functions in $\HH_{\ell+1} \cap \BB_{\ell+1}$:
\begin{equation*}
\trunc_{\ell+1} (\beta_{i,\ell}) := \sum_{k=1}^{N_\ell+1} c^\tau_{k,\ell+1} (\beta_{i,\ell}) \beta_{k,\ell+1},
\end{equation*}
where the coefficients are now
\begin{equation*}
c^\tau_{k,\ell+1}(\beta_{i,\ell}) = \left\{
\begin{array}{ll}
0 & \text{ if } \beta_{k,\ell+1} \in \HH_{\ell+1}, \\
c_{k,\ell+1}(\beta_{i,\ell}) & \text{ otherwise}.
\end{array}
\right.
\end{equation*}
Now, following \cite{Giannelli2012485} we define the truncated hierarchical basis $\TT =\TT_{n-1}$ computed by the following recursive algorithm:
\begin{equation*}\label{E:THB-splines}
\left \{
\begin{array}{l}
\TT_0 := \BB_0, \\
\displaystyle \TT_{\ell+1} := \{\trunc_{\ell+1}(\beta) \in \TT_\ell \mid \supp \beta \not \subset \Omega_{\ell+1} \} \cup \{\beta \in \BB_{\ell+1} : \supp \beta \subset \Omega_{\ell+1} \}.
\end{array}
\right.
\end{equation*}

Notice that to compute the truncation it is only necessary, in the matrix of the two-scale relation $C_\ell^{\ell+1}$, to set to zero the rows corresponding to active and deactivated functions of level $\ell+1$. Successively applying truncation, as it is done in the algorithm, is obtained by multiplying the modified matrix of the two scale relation, in the same way we defined $C_\ell^{\ell+m}$ in \S~\ref{sec:B-splines}.

We also remark that truncation can be also applied to the hierarchical basis $\tilde \HH$, setting to zero the same lines of the matrix for the two-scale relation.

\subsection{Refinement of hierarchical splines}
In this section we review some results about the refinement of hierarchical splines. It is not our objective to introduce or analyse a particular refinement strategy, but to give the main ideas that will serve to introduce, in \S~\ref{sec:REFINE}, the algorithms to compute the refined hierarchical mesh and space.

\subsubsection{Definition of refined hierarchical mesh and space}
{\Rd ADD TEXT}
\begin{definition}
 Let ${\bf\Omega}_n := \{\Omega_0,\Omega_1,\dots,\Omega_n\}$ and ${\bf\Omega}_{n+1}^*:= \{\Omega_0^*,\Omega_1^*,\dots,\Omega_n^*,\Omega_{n+1}^*\}$ be hierarchies of subdomains of $\Omega$ of depth (at most) $n$ and $n+1$, respectively. We say that ${\bf\Omega}_{n+1}^*$ is an \emph{enlargement} of ${\bf\Omega}_n$ if
 $$\Omega_\ell\subset\Omega_\ell^*,\qquad \ell=1,2,\dots,n.$$ 
 \end{definition}


 Let $\HH$ and $\QQ$ be the hierarchical B-spline basis and the hierarchical mesh associated to the hierarchy of subdomains of depth $n$,
${\bf\Omega}_n := \{\Omega_0,\Omega_1,\dots,\Omega_n\}$. For ${\bf\Omega}_{n+1}^*$ an enlargement of ${\bf\Omega}_n$, let $\HH^*$ and $\QQ^*$ be the corresponding \emph{refined hierarchical basis} and \emph{refined hierarchical mesh}, respectively, defined as in Definition~\ref{def:hierarchical}.
 
In~\cite{GJS14} it has been proved that any enlargement of ${\bf\Omega}_n$ gives rise to a new enriched hierarchical B-spline basis $\HH^*$, in the sense that
$$\Span\HH\subset\Span\HH^*.$$
{\Rd SAY SOMETHING ABOUT $\Span\tilde\HH\subset\Span\tilde\HH^*$.}

To compute the enlargement of the subdomains it is necessary to select the areas of the domain which need better approximation, and thus have to be further refined. This is usually decided according to a marking strategy, based on the results of an a-posteriori estimator. Such a choice can be done either by selecting to refine a set of active cells in $\QQ$, as it is usually done in adaptive finite elements, or selecting to refine a set of active basis functions in $\HH$, which is equivalent to refining their support \cite{BG15b}. More precisely, we consider the two following ways of refinement:
\begin{itemize}
\item {\bf Marking active cells:} We consider a subset of active cells $\MM^e\subset\QQ$. Let $\MM^e_\ell:=\MM^e\cap\QQ_\ell$, for $\ell = 0,1,\dots,n-1$. Now, we define the hierarchy of domains ${\bf\Omega}^*_{n+1} := 
\{\Omega_0^*,\Omega_1^*,\dots,\Omega_n^*,\Omega_{n+1}^*\}$ of depth (at most) 
$n+1$, by
\begin{align}\label{E:marking active cells}
\begin{cases}\Omega_0^* &:=\Omega_0,\\
\Omega_{\ell}^* &:=\Omega_{\ell}\cup \D\bigcup_{Q\in\MM^e_{\ell-1}}Q,\qquad \ell = 1,2,\dots,n,\\
\Omega_{n+1}^*&:= \emptyset.
\end{cases}
\end{align}
Notice that $\MM^e\subset\QQ\setminus\QQ^*$, i.e., all cells in $\MM^e$ have been refined.
 \item {\bf Marking basis functions:} We consider a subset of active basis functions $\MM^f\subset\HH$. Let $\MM^f_\ell:=\MM^f\cap\BB_\ell$, for $\ell = 0,1,\dots,n-1$. Now, we define the hierarchy of domains ${\bf\Omega}^*_{n+1} := 
\{\Omega_0^*,\Omega_1^*,\dots,\Omega_n^*,\Omega_{n+1}^*\}$ of depth (at most) 
$n+1$, by
\begin{align}\label{E:marking basis functions}
\begin{cases}\Omega_0^* &:=\Omega_0,\\
\Omega_{\ell}^* &:=\Omega_{\ell}\cup \D\bigcup_{\beta\in\MM^f_{\ell-1}}\supp 
\beta,\qquad \ell = 1,2,\dots,n,\\
\Omega_{n+1}^*&:= \emptyset.
\end{cases}
\end{align}
In this case, $\MM^f\subset\HH\setminus\HH^*$, i.e., all the functions in $\MM^f$ have been removed (or deactivated) from the hierarchical basis $\HH$. 
\end{itemize}

When marking basis functions one has to be careful with the set of functions to deactivate, since it may happen that a function that has not been marked must be deactivated, because its support is contained in the union of the supports of other functions, as it happens in Figure~\ref{}. {\Rd ADD FIGURE}

We would also like to remark that a careless marking can lead to hierarchical bases where coarse and fine functions overlap, because coarse and fine cells are very close to each other or even adjacent. This can be avoided using the so-called using the refinement strategy proposed in \cite{BGi15}, which leads to the so-called \emph{admissible meshes of class $m$}, that is, meshes where on each element only (truncated) functions of $m$ different levels do not vanish. The complexity of this refinement strategy has been studied in \cite{BGMP15}. {\Rd ARE WE GOING TO IMPLEMENT THAT?}

\subsubsection{Refinement matrix between hierarchical spaces (knot insertion)}
In several occasions it is necessary to write a function in the coarse space as a linear combination of functions in the fine space. This is done, for instance, when applying knot insertion, in time dependent problems with adaptive refinement, or in multigrid methods. This coarse-to-fine operation can be computed as as a matrix-vector multiplication, using a rectangular matrix which is easily obtained from the information of active and deactivated functions for each space, that we now explain.

By the way refinement is defined, any active function in $\HH \cap \BB_\ell$ is either in $\HH^* \cap \BB_\ell$ or in $\HH_\ell^* \setminus \HH^*_{\ell+1}$, that is, it is either active or deactivated in the new basis. We can therefore define the rectangular matrix $\tilde I_\ell$ of size $(N^{A^*}_{\ell} + N^{D^*}_{\ell}) \times N^A_\ell$ such that 
\begin{equation*}
(\tilde I_\ell)_{ij} = \left \{ 
\begin{array}{l}
1, \text{ if }  \beta^{*}_{i,\ell} = \beta_{j,\ell}\\
0, \text{ otherwise. }
\end{array}
\right.
\end{equation*}

We define the matrix for refinement $K = K_n$ with the following recursive algorithm:
\begin{enumerate}
\item $K_0 = \tilde I_0$,
\item $K_{\ell+1} = \left [ 
\begin{array}{cc}
K^{A^*}_\ell & 0 \\
K_\ell^{\ell+1} K^{D^*}_\ell & \tilde I_{\ell+1}
\end{array}
\right]$,
\end{enumerate}
where $K_\ell^{A^*}$ and $K_\ell^{D^*}$ are submatrices of $K_\ell$ restricted to the rows corresponding to {\Rd active functions in $\HH^*$ up to level $\ell$, and deactivated functions of level $\ell$, respectively. The matrix $K_\ell^{\ell+1}$ is the submatrix of $C_\ell^{\ell+1}$ restricted to the rows of active and deactivated functions of level $\ell+1$ in $\HH^*$, and the columns of deactivated functions of level $\ell$ in $\HH^*$. }

We remark that this recursive algorithm is independent of the chosen hierarchical space (either standard or simplified). To compute the same matrix for truncated hierachical B-splines, one only needs to replace the matrix $C_\ell^{\ell+1}$ (and its submatrix), by its version for truncated hierarchical splines, as explained in \S~\ref{sec:truncated}.

{\Rd COARSENING?}

\section{Structures for the implementation of hierarchical splines}
In this section we introduce the {\Rd XXXXXXXXXX ADD TEXT}.

\subsection{Structures for the tensor product case}
Our starting point to implement adaptive isogeometric methods with hierarchical splines is the existence of a code capable to solve isogeometric methods with tensor product spaces, as those in Section~\ref{sec:B-splines}.

{\Rd TEXT TEXT TEXT TEXT}

In particular, we need to assume that we have the following functions that work for the tensor product case, and can therefore be used in one single level:
\begin{itemize}
\item {\bf get\_basis\_functions}: for a given cell, compute the indices of the basis functions that do not vanish on the cell. In IGA software this is equivalent to the computation of the connectivity, which is used for assembling the matrix.
\item {\bf get\_cells}: for a given basis function, compute the cells in which the function does not vanish.
\item {\bf get\_neighbors}: for a given basis function, compute the indices of basis functions such that their supports intersect. In IGA software, this information is used for computing the sparsity pattern of the matrix.
\end{itemize}

\section{Setting}

Let $d\ge 1$. We are going to consider tensor-product $d$-variate spline function spaces on $\Omega:=[0,1]^d\subset \RR^d$, where ${\bf p}:=(p_1,p_2,\dots,p_d)$ denotes the vector of polynomial degrees of the splines with respect to each coordinate direction.

\subsection{Underlying sequence of tensor-product spline spaces}

We consider a given sequence $\{\VV_\ell\}_{n\in\NN_0}$ of tensor-product $d$-variate spline spaces such that
\begin{equation}\label{E:tensor-product spaces}
 \VV_0\subset \VV_1\subset \VV_2\subset\VV_3\subset\dots,
\end{equation}
with the corresponding tensor-product B-spline bases denoted by
\begin{equation}\label{E:tensor-product basis}
 \BB_0,  \BB_1,  \BB_2, \BB_3,\dots,
\end{equation}
respectively. %In order to guarantee~\eqref{E:tensor-product spaces}, we assume that if $\xi$ is a knot in $\Xi_{p_i,n_i^\ell}$ with multiplicity $m$, then $\xi$ is also a knot in $\Xi_{p_i,n_i^{\ell+1}}$ with multiplicity at least $m$, for $i=1,\dots,d$ and $\ell\in\NN_0$. 
Furthermore, for $\ell\in\NN_0$, we denote by $\QQ_\ell$ the tensor-product mesh associated to $\BB_\ell$ and we say that $Q\in\QQ_\ell$ is a \emph{cell of level $\ell$}. We now state some well-known properties of the B-spline basis functions~\cite{DeBoor,Schumi}:
\begin{itemize}
\item \emph{Local linear independence.} For any nonempty open set $O\subset\Omega$, the functions in $\BB_\ell$ that do not vanish identically on $O$, are linearly independent on $O$.
\item \emph{Positive partition of unity.} The B-spline basis functions of level $\ell$ form a partition of the unity 
on $\Omega$, i.e.,
 \begin{equation}\label{E:partition of unity in B_0}
  \sum_{\beta\in\BB_\ell} \beta \equiv 1,\qquad\text{on }\Omega.
 \end{equation}
\item \emph{Two-scale relation between consecutive levels.} The B-splines of level $\ell$ can be written as a linear combination of B-splines of level $\ell+1$. More precisely, 
\begin{equation}\label{E:two scale relation}
 \beta_\ell = \sum_{\beta_{\ell+1}\in\CC(\beta_{\ell})} 
c_{\beta_{\ell+1}}(\beta_\ell)\beta_{\ell+1}, 
\qquad \forall\,\beta_\ell\in\BB_\ell,
\end{equation}
where the coefficients $c_{\beta_{\ell+1}}(\beta_\ell)$ are strictly positive, and $\CC(\beta_\ell)\subset\BB_{\ell+1}$ is the set of children of $\beta_\ell$ as defined in~\cite{BG15}. 
\end{itemize}

\begin{remark}
Notice that if we define $c_{\beta_{\ell+1}}(\beta_\ell):=0$ when $\beta_{\ell+1}$ is not a child of $\beta_\ell$, then equation~\eqref{E:two scale relation} can be written as
\begin{equation}\label{E:two scale relation 2}
 \beta_\ell = \sum_{\beta_{\ell+1}\in\BB_{\ell+1}} 
c_{\beta_{\ell+1}}(\beta_\ell)\beta_{\ell+1}, 
\qquad \forall\,\beta_\ell\in\BB_\ell.
\end{equation}

In particular, we remark that
\begin{equation}\label{E:set of children}
\CC(\beta_\ell)=\{\beta_{\ell+1}\in\BB_{\ell+1}\,|\,c_{\beta_{\ell+1}}(\beta_\ell)>0\}\subset\{\beta_{\ell+1}\in\BB_{\ell+1}\,|\,\supp\beta_{\ell+1}\subset\supp\beta_\ell\}.
\end{equation}

\end{remark}

\subsection{Hierarchical B-spline basis and hierarchical spline space}

\begin{definition} 
If $n\in\NN$, 
we say that ${\bf\Omega}_n := \{\Omega_0,\Omega_1,\dots,\Omega_n\}$ is a 
\emph{hierarchy of subdomains of $\Omega$ of depth $n$} if
\begin{enumerate}
 \item[(i)] $\Omega_\ell$ is the union of cells of level 
$\ell-1$, for $\ell = 1,2,\dots,n$.
 \item[(ii)]$\Omega = \Omega_0 \supset \Omega_1 \supset \dots \supset 
\Omega_{n-1}\supset \Omega_n = \emptyset$.
\end{enumerate} 
\end{definition}

We now define the hierarchical B-spline basis ${\HH}= {\HH}({\bf\Omega}_n)$ by 
% in the following recursive way
% \begin{equation}\label{E:definition of Hltilde}
% \begin{cases}\HH_0:=\BB_0,\\
%  {\HH}_{\ell+1}:=\{\beta\in\HH_{\ell}\,|\,\supp\beta\not\subset\Omega_{\ell+1}\}\cup\{\beta\in\BB_{\ell+1}\,|\, \supp\beta\subset\Omega_{\ell+1}\},\qquad\ell=0,\dots,n-2.\\
%  \HH:=\HH_{n-1}.\end{cases}
% \end{equation}
% If $\RRR_\ell:=\HH_\ell\setminus\HH_{\ell+1}$, then
% $$\RRR_\ell=\{\beta\in\HH_{\ell}\,|\,\supp\beta\subset\Omega_{\ell+1}\}=\{\beta\in\BB_{\ell}\,|\,\supp\beta\subset\Omega_{\ell+1}\}.$$
% Notice that in order to get $\HH_{\ell+1}$ from $\HH_{\ell}$ we replace the set $\RRR_\ell$ by
% $$\{\beta\in\BB_{\ell+1}\,|\, \supp\beta\subset\Omega_{\ell+1}\}.$$
% Moreover, it is easy to check that
\begin{equation}\label{E:Hierarchical basis}
{\HH}= \bigcup_{\ell = 0}^{n-1} \{\beta \in \BB_\ell \mid \supp \beta 
\subset \Omega_\ell \wedge  \supp \beta \not\subset \Omega_{\ell+1}\}.
\end{equation} 
We say that $\beta$ is \emph{active} if $\beta\in\HH$. The 
corresponding underlying mesh $\QQ = \QQ({\bf\Omega}_n)$ is given 
by
\begin{equation}\label{E:hierarchical mesh}
\QQ:= \bigcup_{\ell = 0}^{n-1} \{ Q\in\QQ_\ell\,\mid\, Q\subset \Omega_\ell 
\,\wedge\, Q\not\subset \Omega_{\ell+1}\}, 
\end{equation}
and we say that $Q$ is an \emph{active cell} is $Q\in\QQ$, or that $Q$ is an 
\emph{active cell of level $\ell$} if $Q\in\QQ\cap \QQ_\ell$.


Unlike the B-spline bases $\BB_\ell$ for tensor-product spline spaces, the hierarchical B-spline basis $\HH$ does not constitute a partition of the unity. Instead, in view of the linear independence of functions in $\HH$ and taking into account that $\VV_0=\Span\BB_0\subset\Span\HH$, we have that there exists a set $\{a_\beta\}_{\beta\in\HH}\subset \RR$, uniquely determined, such that
 \begin{equation}\label{E:partition of the unity in the hierarchical space}
\sum_{\beta\in {\HH}} a_\beta \beta \equiv 1, \qquad\text{on } \Omega. 
\end{equation}
 It can be proved that $a_\beta\ge 0$, for all $\beta\in\HH$. On the other hand, we remark that these coefficients depend on the hierarchy of subdomains~${\bf\Omega}_n$.



\section{Refinement of hierarchical spline spaces}\label{S:refinement}

In this section, we present a precise technique to refine locally a given hierarchical spline space $\Span\HH$.


\begin{definition}
 Let ${\bf\Omega}_n := \{\Omega_0,\Omega_1,\dots,\Omega_n\}$ and ${\bf\Omega}_{n+1}^*:= \{\Omega_0^*,\Omega_1^*,\dots,\Omega_n^*,\Omega_{n+1}^*\}$ be hierarchies of subdomains of $\Omega$ of depth (at most) $n$ and $n+1$, respectively. We say that ${\bf\Omega}_{n+1}^*$ is an \emph{enlargement} of ${\bf\Omega}_n$ if
 $$\Omega_\ell\subset\Omega_\ell^*,\qquad \ell=1,2,\dots,n.$$ 
 \end{definition}

 Let $\HH$ and $\QQ$ be the hierarchical B-spline basis and the hierarchical mesh associated to the hierarchy of 
subdomains of depth $n$,
${\bf\Omega}_n := \{\Omega_0,\Omega_1,\dots,\Omega_n\}$.
 
Let ${\bf\Omega}_{n+1}^*$ be an enlargement of ${\bf\Omega}_n$. Now, the corresponding hierarchical B-spline basis ${\HH}^*$ and 
\emph{refined} 
mesh $\QQ^*$ are given by 
\begin{equation}
{\HH}^*:= \bigcup_{\ell = 0}^{n} \{\beta \in \BB_\ell \mid \supp \beta 
\subset \Omega_\ell^* \wedge  \supp \beta \not\subset \Omega_{\ell+1}^*\},
\end{equation}
and
$$\QQ^*:= \bigcup_{\ell = 0}^{n} \{ Q\in\QQ_\ell \,\mid\, Q\subset \Omega_\ell^* 
\,\wedge\, Q\not\subset \Omega_{\ell+1}^*\}.$$



Let $\{a_\beta^*\}_{\beta\in{\HH}^*}$ denote the sequence of coefficients (with respect to the hierarchy ${\bf\Omega}_{n+1}^*$) such that $$\sum_{\beta\in{\HH}^*} a_\beta^*\beta \equiv 1,\qquad\text{ on }\Omega.$$ 



In~\cite{GJS14} has been proved that any enlargement of ${\bf\Omega}_n$ gives rise to a new enriched hierarchical B-spline basis $\HH^*$, in the sense that
$$\Span\HH\subset\Span\HH^*.$$
In order to enlarge the given subdomains ${\bf\Omega}_n = \{\Omega_0,\Omega_1,\dots,\Omega_n\}$ we have to select the areas in $\Omega$ where more ability of approximation is required. Such a choice can be done by selecting to \emph{refine} some active basis functions or some active cells. More precisely, we consider the two following ways of enlarging the hierarchy ${\bf\Omega}_n$:
\begin{itemize}
 \item {\bf Marking basis functions:} We consider a subset $\MM$ of active B-spline basis functions, i.e., $\MM\subset\HH$. Let $\MM_\ell:=\MM\cap\BB_\ell$, for $\ell = 0,1,\dots,n-1$. Now, we define the hierarchy of domains ${\bf\Omega}^*_{n+1} := 
\{\Omega_0^*,\Omega_1^*,\dots,\Omega_n^*,\Omega_{n+1}^*\}$ of depth (at most) 
$n+1$, by
\begin{align}\label{E:marking basis functions}
\begin{cases}\Omega_0^* &:=\Omega_0,\\
\Omega_{\ell}^* &:=\Omega_{\ell}\cup \D\bigcup_{\beta\in\MM_{\ell-1}}\supp 
\beta,\qquad \ell = 1,2,\dots,n,\\
\Omega_{n+1}^*&:= \emptyset.
\end{cases}
\end{align}
Let $\HH^*$ be the hierarchical B-spline basis associated to ${\bf\Omega}^*_{n+1}$. Notice that $\MM\subset\HH\setminus\HH^*$, i.e., at least the functions in $\MM$ have been removed (or deactivated) from the hierarchical basis $\HH$. 
\item {\bf Marking active cells:} We consider a subset $\MM$ of active cells, i.e., $\MM\subset\QQ$. Let $\MM_\ell:=\MM\cap\QQ_\ell$, for $\ell = 0,1,\dots,n-1$. Now, we define the hierarchy of domains ${\bf\Omega}^*_{n+1} := 
\{\Omega_0^*,\Omega_1^*,\dots,\Omega_n^*,\Omega_{n+1}^*\}$ of depth (at most) 
$n+1$, by
\begin{align}\label{E:marking active cells}
\begin{cases}\Omega_0^* &:=\Omega_0,\\
\Omega_{\ell}^* &:=\Omega_{\ell}\cup \D\bigcup_{Q\in\MM_{\ell-1}}Q,\qquad \ell = 1,2,\dots,n,\\
\Omega_{n+1}^*&:= \emptyset.
\end{cases}
\end{align}
Let $\HH^*$ be the hierarchical B-spline basis associated to ${\bf\Omega}^*_{n+1}$ and $\QQ^*$ be the corresponding hierarchical mesh. In this case, $\MM\subset\QQ\setminus\QQ^*$, i.e., all cells in $\MM$ have been refined. 
\end{itemize}


% In the case of hierarchy of subdomains satisfying the support condition, we can 
% \emph{easily} compute the active functions $\beta$ in the finer space having nonzero weight, i.e. 
% $\beta\in\HH^*$, from the knowledge of active functions in the coarse basis $\HH$, provided we have a global numbering for all the basis functions 
% in $\BB_\ell$, for $\ell \in\NN_0$.

\section{Algorithms for initialization and refinement of a hierarchical B-spline basis}


Here we describe an algorithm to compute the active B-splines in the finer basis taking advantage of the knowledge of the active B-splines in the current coarse basis.

We consider a global numbering for all the basis functions in $\BB_\ell$, for each $\ell \in\NN_0$, and assume that we have available the following basic routines related with the underlying tensor-product spline spaces:
\begin{enumerate}
 \item[(1)] Basic routines in each tensor-product space $\VV_\ell$:
\begin{itemize}
 \item $I = \verb+get_cells+ (i_\beta,\ell)$, where $i_\beta$ is the global 
index of a function $\beta\in\BB_\ell$, and $I$ contains the global indices 
of the cells in $\QQ_{\ell}$ which are subsets of $\supp\beta$.
\item $I = \verb+get_neighbors+ (i_\beta,\ell)$, where $i_\beta$ is the global 
index of a function $\beta\in\BB_\ell$, and $I$ contains the global indices 
of functions in $\BB_{\ell}$ whose supports have at least one cell of level $\ell$ within $\supp\beta$.
\item $I = \verb+get_basis_functions+ (i_Q,\ell)$, where $i_Q$ is the global index of a cell $Q\in\QQ_\ell$ and $I$ contains the global indices 
of functions in $\BB_{\ell}$ that do not vanish on $Q$.
\end{itemize}
\item[(2)] Basic routines linking two consecutive levels of the tensor-product spaces ($\VV_\ell$ and $\VV_{\ell+1}$):
\begin{itemize}
\item $I = \verb+split_cell+ (i_Q,\ell)$, where $i_Q$ is the global index of a cell $Q\in\QQ_\ell$ and $I$ contains the global indices 
of the cells in $\QQ_{\ell+1}$ which are inside of $Q$.
\item $[I,c] = \verb+split_fun+ (i_\beta,\ell)$, where $i_\beta$ is the global 
index of a function $\beta\in\BB_\ell$, $I$ contains the global indices of all children of $\beta$, and $c$ 
is an array with the corresponding coefficients given by~\eqref{E:two scale relation}. 
\end{itemize}
\end{enumerate}
\begin{remark}\label{R:two-scale relation}
The routines listed above are in fact elementary. The \emph{hardest} thing in the previous routines is the computation of the coefficients for the two-scale relation~\eqref{E:two scale relation} in the function \texttt{split\_fun}. Nevertheless, by virtue of the tensor-product structure of B-splines, this task can be done by computing the corresponding coefficients in the two-scale relation for univariate B-splines and Kronecker products. On the other hand, it is important to remark that the coefficients in the univariate case can be computed using knot insertion formulae. 
It is important to mention that these coefficients will be used in our algorithms below to compute the coefficients of the hierarchical basis functions for the partition of the unity~(cf.~\eqref{E:partition of the unity in the hierarchical space}). We remark that some a posteriori error estimators may require this information~\cite{BG15b}.

Finally, we remark that if we do not need the explicit knowledge of the coefficients in~\eqref{E:partition of the unity in the hierarchical space}, we can consider a simple version of the function $\texttt{split\_fun}$ given by 
 $$I = \texttt{split\_fun} (i_\beta,\ell),$$ where $i_\beta$ is the global 
index of a function $\beta\in\BB_\ell$ and $I$ contains the global indices of 
the children of $\beta$. In this case, the algorithms described below can also be considerably simplified. 
\end{remark}


The hierarchical mesh $\QQ$ can be defined through the variable $\mesh = \{E^A_\ell,E^D_\ell\}_{\ell=0}^{n-1}$,  where
\begin{itemize}
 \item $E^A_\ell$ is the array containing the global indices of active cells of level $\ell$, i.e., cells in $\QQ\cap\QQ_\ell$.
 \item $E^D_\ell$ is the array containing the global indices of deactivated cells of level $\ell$, i.e., cells $Q\in\QQ_\ell$ such that $Q\subset\Omega_{\ell+1}$. Notice that $E^D_{n-1}=\emptyset$.
 \end{itemize}
 On the other hand, the hierarchical B-spline basis $\HH$ associated to $\QQ$ can be described through the variable $\basis = \{F^A_\ell,F^D_\ell, W_\ell\}_{\ell=0}^{n-1}$, where
\begin{itemize}
 \item $F^A_\ell$ is the array containing the global indices of active B-splines of level $\ell$, i.e., functions in $\HH\cap\BB_\ell$.
  \item  $F^D_\ell$ is an array containing the global indices of B-splines in $\BB_\ell$ whose supports are subsets of $\Omega_{\ell+1}$, i.e.,
$$F^D_\ell:= \{i_\beta\,|\,\beta\in\BB_\ell\quad\wedge\quad \supp\beta\subset\Omega_{\ell+1}\}.$$
Notice that $F^D_{n-1}=\emptyset$. 
 \item $W_\ell$ is an array containing the values of the coefficients $a_\beta$ for the partition of the unity~\eqref{E:partition of the unity in the hierarchical space} corresponding to the active B-splines $\beta$ of level $\ell$, i.e., to the functions in $F^A_\ell$.
\end{itemize}



\subsection{Getting the new active basis functions from the current ones}
 

Let $\marked=\{M_\ell\}_{\ell=0}^{n-1}$, where $M_\ell\subset F^A_\ell$ (or $M_\ell\subset E^A_\ell$) is the set of global indices of \emph{marked} functions (or elements) of level $\ell$, i.e., functions (or elements) in $\MM_\ell$. Now, we present an algorithm for updating the information in $\mesh$ and $\basis$ when enlarging the hierarchy of subdomains ${\bf \Omega}_n$ with the marked functions or elements as explained in the previous section, cf.~\eqref{E:marking basis functions} and~\eqref{E:marking active cells}.

\% This function updates $\mesh$ and $\basis$ when enlarging the current subdomains with the marked functions (or elements) given in $\marked$
\begin{algorithm}
\caption{Refine}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\mesh, \basis, \marked$
\If{(Marking functions)}
\State $\markedelements \gets \textbf{compute\_cells\_to\_refine} \, (\{\activeelements{\ell}\}, \{\marked_\ell\})$
\ElsIf{(Marking elements)}
\State $\markedelements \gets \marked$
\EndIf
\State $\mesh \gets$ \textbf{refine\_hierarchical\_mesh}\, ($\markedelements$) \Comment{{\Rd Think about these two lines}}
\State $\newcells \gets \textbf{get\_children} \, (\markedelements)$
\State $\basis \gets \textbf{refine\_hierarchical\_space} \, (\mesh, \basis, \marked, \newcells)$
\Statex \textbf{Output:} $\mesh, \basis$
\end{algorithmic}
\end{algorithm}


%% \begin{algorithm}[H]{$\texttt{function}\quad [\mesh,\basis] = \texttt{refine}(\mesh,\basis,\marked)$} 
%% \caption{$\texttt{refine}$ (REFINE THE HIERARCHICAL MESH AND SPACE)}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% \medskip

%% \% This function updates $\mesh$ and $\basis$ when enlarging the current subdomains with the marked functions (or elements) given in $\marked$


%% \KwData{(Data for $\QQ$, $\HH$ and $\MM$): $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_\ell\\ \basis = \{F^A_\ell, F^D_\ell, W_\ell\}_\ell\\ \marked=\{M_\ell\}_\ell \end{cases}\,\, (\ell=0,1,\dots,n-1).$}
%%  \KwResult{(Data for $\QQ^*$ and $\HH^*$):  $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_\ell\\ \basis = \{F^A_\ell, F^D_\ell, W_\ell\}_\ell \end{cases}\,\, (\ell=0,1,\dots,n).$}

%% \medskip

%% \begin{enumerate}
%%  \item[] \% REFINE MESH\;
%%   \item[] \Switch{marked functions or elements}{
%%   \begin{enumerate}
%%    \item[1.]\lCase{functions,}{$\markedelements = \texttt{compute\_cells\_to\_refine}(\{E^A_\ell\}_{\ell=0}^{n-1}, \marked)$}
%% \item[2.]\lCase{elements,}{$\markedelements = \marked$}
%% \end{enumerate}
%% }
%% \item[]\%   $\markedelements$ contains the cells that have to be refined\;
  
%% \item[3.]$[\mesh, \newcells] = \texttt{refine\_hierarchical\_mesh}(\mesh, \markedelements)$\;
%% %\item[3.]$[\mesh, \newcells] = \texttt{update\_active\_cells}(\mesh, \markedelements)$\;
%%  \item[]\% $\newcells$ contains the new cells\;
%%  \item[]\% REFINE SPACE\;
%% \item[4.] $\basis = \texttt{refine\_hierarchical\_space}(\mesh, \basis, \marked, \newcells)$\;
%% \end{enumerate}
%%  \medskip 
%% \end{minipage}
%% }
%% \end{algorithm}

\subsubsection{Routines for the mesh} \mbox{}

% \begin{algorithm}[H]{$\texttt{function}\quad [\mesh,\newcells] = \texttt{refine\_hierarchical\_mesh}(\mesh, \markedelements)$} 
% \caption{$\texttt{refine\_hierarchical\_mesh}$}
% \bigskip
% \doublebox{
% \begin{minipage}{.95\textwidth}
% \medskip
% \KwData{(Data for $\QQ$ and $\markedelements$): $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_\ell\\  \markedelements = \{\markedelements_\ell\}_\ell \end{cases}\,\, (\ell=0,1,\dots,n-1).$}
%  \KwResult{(Data for $\QQ^*$ and $\newcells$):  $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_\ell\\ \newcells = \{\newcells_\ell\}_\ell\end{cases}\,\, (\ell=0,1,\dots,n).$}
% \medskip
% 
% $[\mesh,\newcells] = \texttt{update\_active\_cells}(\mesh,\markedelements)$\;
% 
%  \end{minipage}
% }
% \end{algorithm}



\begin{algorithm}
\caption{$\texttt{compute\_cells\_to\_refine}$}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\{\activeelements{\ell}\}, \{\functionstoremove_\ell\}$
\For{$\ell=0,\ldots,n-1$}
 \State $\markedelements_\ell \gets \textbf{get\_cells} \, (\functionstoremove_\ell)$
 \State $\markedelements_\ell \gets \markedelements_\ell\cap \activeelements{\ell}$
\EndFor
\Statex \textbf{Output:} $\{\markedelements_\ell\}$
\end{algorithmic}
\end{algorithm}


%% \begin{algorithm}[H]{$\texttt{function}\quad \markedelements = \texttt{compute\_cells\_to\_refine}(\{E^A_\ell\}_{\ell=0}^{n-1}, \marked)$} 
%% \caption{$\texttt{compute\_cells\_to\_refine}$}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% \medskip
%% \% This function computes the indices of cells that have to be splitted when marking for refinement the functions in $\marked$\,
%% \medskip

%%  \KwData{$\begin{cases} \{E^A_\ell\}_\ell \text{ (indices of active cells)}\\  \marked = \{M_\ell\}_\ell \end{cases}\,\, (\ell=0,1,\dots,n-1).$}
%%  \KwResult{$\markedelements = \{\markedelements_\ell\}_{\ell=0}^{n-1}$ (Indices of cells that have to be refined)}
%% \medskip

%%  \ForEach{$\ell=0,1,\dots,n-1$}{
%%  \begin{enumerate}
%%   \item[1.] Use \texttt{get\_cells} to compute the set of indices $\markedelements_\ell$ of the cells of level $\ell$ that are included in the support of functions in $M_\ell$\;
%%   \item[2.] $\markedelements_\ell \leftarrow \markedelements_\ell\cap E^A_\ell$ \% Remove the nonactive cells from $\markedelements_\ell$\;
%%  \end{enumerate}
%%   }
%% \medskip 
%% \end{minipage}
%% }
%% \end{algorithm}



\begin{algorithm}
\caption{Refine\_hierarchical\_mesh}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\mesh, \{\markedelements\}$
\If {$\markedelements_{n-1} \not = \emptyset$} 
\State $\mesh \gets \textbf{initialize\_empty\_level \, (n)}$
\EndIf
\For{$\ell = 0, \ldots, n-1$}
\State $\activeelements{\ell} \gets \activeelements{\ell} \cap \markedelements_\ell$
\State $\deactelements{\ell} \gets \deactelements{\ell} \cup \markedelements_\ell$
\State $\newcells_\ell \gets \textbf{get\_children} \, (\markedelements_\ell)$ \Comment{{\Rd Should we move this out?}}
\State $\activeelements{\ell+1} \gets \activeelements{\ell+1} \cup \newcells_{\ell+1}$
\EndFor
\Statex \textbf{Output:} $\mesh, {\Rd \{\newcells_\ell\}}$
\end{algorithmic}
\end{algorithm}

%% \begin{algorithm}[H]{$\texttt{function}\quad [\mesh,\newcells] = \texttt{refine\_hierarchical\_mesh}(\mesh,\markedelements)$} 
%% \caption{\texttt{update\_active\_cells}}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% \medskip

%% \% This function updates the active and deactive cells in each level when refining the cells in $\markedelements$

%% \KwData{(Data for $\QQ$ and $\markedelements$): $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_\ell\\  \markedelements = \{\markedelements_\ell\}_\ell \end{cases}\,\, (\ell=0,1,\dots,n-1).$}
%%  \KwResult{(Data for $\QQ^*$ and $\newcells$):  $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_\ell\\ \newcells = \{\newcells_\ell\}_\ell\end{cases}\,\, (\ell=0,1,\dots,n).$}
%% \medskip

%% \begin{enumerate}
%% \item[1.] \lIf{$\markedelements_{n-1}\neq \emptyset$,} {$E^A_{n} = E^D_n = \emptyset$}

%% \item[]\ForEach{$\ell=0,1,\dots,n-1$}{
%% \begin{enumerate}
%%  \item[2.]$E^A_\ell \leftarrow E^A_\ell \setminus \markedelements_\ell$ \% Update $E^A_\ell$ by removing the cells to be refined\;
%%  \item[3.]$E^D_\ell \leftarrow E^D_\ell \cup \markedelements_\ell$ \% Update $E^D_\ell$ by adding the cells that were deactivated\;
%%  \item[4.] Use \texttt{split\_cell} to get the set of indices $\newcells_{\ell+1}$ of cells of level $\ell+1$ which are inside of the cells in $\markedelements_\ell$\;
%%  \item[5.]$E^A_{\ell+1} \leftarrow E^A_{\ell+1}\cup \newcells_{\ell+1}$ \% Update $E^A_{\ell+1}$ by adding the new active cells of level $\ell+1$; 
%% \end{enumerate}
%% }
%% \end{enumerate}
%% \end{minipage}
%% }
%% \end{algorithm}

\subsubsection{Routines for the space}

For the routines in this section notice that the variable $\mesh$ is already updated, i.e., it contains the information about $\QQ^*$.

\begin{algorithm}
\caption{$\texttt{refine\_hierarchical\_space}$}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\mesh, \basis, \{\marked_\ell\}, \{\newcells_\ell\}$
\State $\functionstoremove \gets \textbf{compute\_functions\_to\_deactivate} \, (\mesh, \basis, \marked)$
\If {$\marked_{n-1} \not = \emptyset$} 
  \State $\basis \gets \textbf{initialize\_empty\_level \, (n)}$
\EndIf
\State $\texttt{REFINED}\_\basis \gets \textbf{Update\_Active\_Functions} \, (\mesh, \basis, \functionstoremove, \marked)$ \Comment{Split in two (elements and functions)?}
\State {\Rd $K \gets \textbf{Compute\_Refinement\_Matrix} \, (\basis, \texttt{REFINED}\_\basis)$}
\Statex \textbf{Output:} $\texttt{REFINED}\_\basis$, {\Rd $K$} \Comment The refined space
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Compute\_Functions\_To\_Deactivate}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\mesh, \basis, \marked$
\For {$\ell = 0, \ldots, n-1$}
  \If{(Marking functions)}
    \State $\functionstoremove_\ell \gets \textbf{get\_neighbors} \, (\marked_\ell)$
    \State $\functionstoremove_\ell \gets (\functionstoremove_\ell \cap \activefunctions{\ell} ) \setminus \marked_\ell$ \Comment{{\Rd Why not $\functionstoremove_\ell \gets \functionstoremove_\ell \cap \activefunctions{\ell}$?}}
  \ElsIf{(Marking elements)}
    \State $\functionstoremove_\ell \gets \textbf{get\_basis\_functions} \, (\marked_\ell)$
    \State $\functionstoremove_\ell \gets \functionstoremove_\ell \cap \activefunctions{\ell}$
  \EndIf
  \State {\Rd Update $\functionstoremove_\ell$ by removing the functions that have al least one active cell of level $\ell$ within their supports. Use \texttt{get\_cells}\;}
  \If {(Marking functions)} 
     \State $\functionstoremove_\ell \gets \functionstoremove_\ell \cup \marked_\ell$
  \EndIf
\EndFor
\Statex \textbf{Output:} $\{\functionstoremove\}$
\end{algorithmic}
\end{algorithm}

%% \begin{algorithm}[H]{$\texttt{function}\quad \basis = \texttt{refine\_hierarchical\_space}(\mesh, \basis, \marked, \newcells)$} 
%% \caption{$\texttt{refine\_hierarchical\_space}$}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% {%\footnotesize
%% \medskip

%% \KwData{(Data for $\QQ^*$, $\HH$, $\MM$, and $\newcells$): $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_{\ell=0}^{n}\\ \basis = \{F^A_\ell, F^D_\ell, W_\ell\}_\ell\\ \marked=\{M_\ell\}_\ell\\  \newcells = \{\newcells_\ell\}_\ell \end{cases}(\ell=0,\dots,n-1).$}
%%  \KwResult{(Data for $\HH^*$):  $\basis = \{F^A_\ell, F^D_\ell, W_\ell\}_\ell\quad (\ell=0,1,\dots,n).$}
%% \medskip
 
%%  \begin{enumerate}
%%   \item [1.]$\functionstoremove = \texttt{compute\_functions\_to\_deactivate}(\mesh, \basis, \marked)$\;
%%   \item[]\% $\functionstoremove$ contains all B-splines that have to be deactivated\;
%% \item[2.]$\basis=\texttt{update\_active\_functions}(\mesh,\basis,\functionstoremove,\newcells)$\;
%%  \end{enumerate}
%%  }
%%  \end{minipage}
%% }
%% \end{algorithm}


%% \begin{algorithm}[H]{$\texttt{function}\quad \functionstoremove = \texttt{compute\_functions\_to\_deactivate}(\{E^A_\ell\}_{\ell=0}^{n}, \{F^A_\ell\}_{\ell=0}^{n-1},\marked)$} 
%% \caption{\texttt{compute\_functions\_to\_deactivate}}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% {%\footnotesize
%% \medskip
%% \% This function computes the indices of the functions that have to be deactivated when marking for refinement the functions (or elements) in $\marked$\,
%% \medskip

%%  \KwData{$\begin{cases} \{E^A_\ell\}_{\ell=0}^n \text{ (indices of active cells)}\\ \{F^A_\ell\}_\ell\text{ (indices of active basis functions)}\\ \marked = \{M_\ell\}_\ell \end{cases}\,\, (\ell=0,1,\dots,n-1).$}
%%  \KwResult{$\functionstoremove = \{\functionstoremove_\ell\}_{\ell=0}^{n-1}$ (Indices of basis functions that have to be deactivated)}
%% \medskip

%%  \ForEach{$\ell=0,1,\dots,n-1$}{
%%  \begin{enumerate}
%%   \item[] \% Computation of functions which \emph{possibly} have to be removed\;
%%  \item[]\Switch{marked functions or elements}{
%% \Case{functions,}{
%% \begin{enumerate}
%%  \item[1.] Use \texttt{get\_neighbors} to compute the set of indices $\functionstoremove_\ell$ of functions of level $\ell$ whose supports intersect the support of a function in $M_\ell$\;
%%  \item[2.] $\functionstoremove_\ell \leftarrow (\functionstoremove_\ell\cap F^A_\ell)\setminus M_\ell$ \% Remove from $\functionstoremove_\ell$ the nonactive functions and the active functions already selected for deactivation\; 
%% \end{enumerate}
%% }
%%  \Case{elements,}{
%%  \begin{enumerate}
%%   \item[3.] Use \texttt{get\_basis\_functions} to compute the set of indices $\functionstoremove_\ell$ of functions of level $\ell$ whose supports intersect at least one cell in $M_\ell$\;
%%   \item[4.] $\functionstoremove_\ell \leftarrow (\functionstoremove_\ell\cap F^A_\ell)$ \% Remove from $\functionstoremove_\ell$ the nonactive functions\;
%%  \end{enumerate}
%% }
%% }
%% \item[] \% Computation of functions which \emph{in fact} have to be removed\;
%% \item[5.] Update $\functionstoremove_\ell$ by removing the functions that have al least one active cell of level $\ell$ within their supports. Use \texttt{get\_cells}\;
%%  \item[6.] \lIf{marking functions,}{$\functionstoremove_\ell =  \functionstoremove_\ell\cup M_\ell $}
%%  \end{enumerate}
%%  }
%% \medskip
%% }
%% \end{minipage}
%% }
%% \end{algorithm}

%% \begin{algorithm}[H]{$\texttt{function}\quad \basis = \texttt{update\_active\_functions}(\mesh,\basis,\functionstoremove,\newcells)$\;} 
%% \caption{\texttt{update\_active\_functions}}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% %\begin{center}
%% \medskip
%% {%\footnotesize
%% \% This function updates the active and deactive B-spline basis functions. The inputs $\mesh$ and $\newcells$ are already updated (see \texttt{refine\_hierarchical\_mesh}) and $\functionstoremove$ contains the indices of \emph{all B-splines that have to be deactivated} (see \texttt{compute\_functions\_to\_deactivate}). Finally, the variable $\basis$ in the input contains the information before updating the space\,

%% \KwData{(Data for $\QQ^*$, $\HH$, $\functionstoremove$ and $\newcells$): $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_{\ell=0}^{n}\\ \basis = \{F^A_\ell, F^D_\ell, W_\ell\}_{\ell=0}^{n-1}\\ \functionstoremove=\{\functionstoremove_\ell\}_{\ell=0}^{n-1}\\  \newcells = \{\newcells_\ell\}_{\ell=0}^n \end{cases}$}
%%  \KwResult{(Data for $\HH^*$):  $\basis = \{F^A_\ell, F^D_\ell, W_\ell\}_{\ell=0}^n$}
%% \medskip

%% \begin{enumerate}
%%  \item[1.] \lIf{ $\functionstoremove_{n-1}\neq \emptyset$,} {$F^A_n=F^D_n=W_n=\emptyset$}
%% \item[]\% Update of $\{F^A_\ell,F^D_\ell,W_\ell\}_\ell$\;
%% \item[]\ForEach{$\ell=0,1,\dots,n-1$}{
%% \begin{enumerate}
%%  \item[2.] $\functionstoremove_\ell \leftarrow \functionstoremove_\ell \cup (F^A_\ell\cap F^D_\ell)$ \% This line is important for $\ell\ge 1$\;
%% \item[3.]$F^A_\ell \leftarrow F^A_\ell \setminus \functionstoremove_\ell$ \% Remove $\functionstoremove_\ell$ from the active functions of level $\ell$\;
%% \item[4.]Save in \texttt{W} the values of $W_\ell$ corresponding to functions in $\functionstoremove_\ell$ and update $W_\ell$ by removing these values\;
%%  \item[5.]$F^D_\ell\leftarrow F^D_\ell\cup \functionstoremove_\ell$ \% Update $F^D_\ell$ by adding the functions to be deactivated\;
%% \item[]\ForEach{$\beta$ in $\functionstoremove_\ell$}{
%% \begin{enumerate}
%%   \item [6.] Compute the set of indices $I_\beta$ of the B-splines of level $\ell+1$ and the corresponding coefficients $c$ of the two-scale relation~\eqref{E:two scale relation} when writing $\beta$ as a linear combination of functions in $\BB_{\ell+1}$ 
%%  \item[7.] Use \texttt{get\_cells} to update $F^D_{\ell+1}$ by adding the functions in $(I_\beta\setminus F^A_{\ell+1})\setminus F^D_{\ell+1}$ that have no active cell of level $\ell+1$ within its support.
%%  \item[8.] $F^A_{\ell+1}\leftarrow F^A_{\ell+1}\cup I_\beta$ \% Enlarge $F^A_{\ell+1}$ by adding the \emph{possible} new active functions\;
%%  \item[9.] Enlarge $W_{\ell+1}$ in order to match with the new $F^A_{\ell+1}$, setting equal to zero the coefficients corresponding to the new functions in $F^A_{\ell+1}$.
%%   \item[] \% Now, we update the values in $W_{\ell+1}$
%%   \item[10.] \lForEach{ $\beta_{\ell+1}$ in $I_\beta$}{
%%   $a_{\beta_{\ell+1}}\leftarrow a_{\beta_{\ell+1}}+a_\beta*c_{\beta_{\ell+1}}$, where $a_\beta$ is the value in \texttt{W} corresponding to $\beta$, and $a_{\beta_{\ell+1}}$ and $c_{\beta_{\ell+1}}$ are the values in $W_{\ell+1}$ and $c$, respectively, corresponding to $\beta_{\ell+1}$}
%%  \end{enumerate}
%% }
%% \item[]\% Now, we activate B-splines of level $\ell+1$ that are not children of any deactivated B-spline of level $\ell$\;
%% \item[11.] Use \texttt{get\_basis\_functions} to compute the indices $I$ of the B-splines of level $\ell+1$ that do not vanish in some cell of $\newcells_{\ell+1}$\;
%% \item[12.] $I\leftarrow I\setminus F^A_{\ell+1}$ \% Remove from $I$ the functions which were already active\;
%% \item[13.] Use \texttt{get\_cells} to update $I$ by removing the functions such that have at least one cell of level $\ell+1$ in their support that does not belong to $E^A_{\ell+1}\cup E^D_{\ell+1}$\;
%% \item[14.] $F^A_{\ell+1}\leftarrow F^A_{\ell+1}\cup I$\;
%% \item [15.] Enlarge $W_{\ell+1}$ in order to match with the new $F^A_{\ell+1}$, setting equal to zero the coefficients corresponding to the new functions in $F^A_{\ell+1}$\;
%% \end{enumerate}
%% }
%% \end{enumerate}
%% \medskip
%% }%\end{center}
%% \end{minipage}
%% }
%% \end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\begin{algorithm}
\caption{Update\_active\_functions: simplified hierarchical space}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\mesh, \basis, \{\functionstoremove\}$
\For {$\ell = 0, \ldots, n-1$}
  \State $\activefunctions{\ell}\gets \activefunctions{\ell} \setminus \functionstoremove_\ell$
  \State $\deactfunctions{\ell}\gets \deactfunctions{\ell} \cup \functionstoremove_\ell$
  \State $\tt{F^C} \gets \textbf{get\_children} \, (\functionstoremove_\ell)$
  \State $\tt{F^C} \gets \tt{F^C} \setminus \activefunctions{\ell+1} \cup \deactfunctions{\ell+1}$ 
  \State $\activefunctions{\ell+1} \gets (\activefunctions{\ell+1} \cup \tt{F^C})$
  \State {\Rd Use \texttt{get\_cells} to update $\functionstoremove_{\ell+1}$ by adding the functions in $\tt{F^C}$ that have no active cell of level $\ell+1$ within its support.}
\EndFor
\Statex \textbf{Output:} ${\Rd \texttt{REFINED}\_\basis (\{\activefunctions{ }\}, \{\deactfunctions{} \})}$
\end{algorithmic}
\end{algorithm}

%% \begin{algorithm}[H]{$\texttt{function}\quad \basis = \texttt{update\_active\_functions}(\mesh,\basis,\functionstoremove,\newcells)$\;} 
%% \caption{\texttt{update\_active\_functions}}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% %\begin{center}
%% \medskip
%% {%\footnotesize
%% \% This function updates the active and deactivated B-spline basis functions, {\Rd when using the simplified hierarchical space}. The inputs $\mesh$ and $\newcells$ are already updated (see \texttt{refine\_hierarchical\_mesh}) and $\functionstoremove$ contains the indices of \emph{all B-splines that have to be deactivated} (see \texttt{compute\_functions\_to\_deactivate}). Finally, the variable $\basis$ in the input contains the information before updating the space\,

%% \KwData{(Data for $\QQ^*$, $\HH$, $\functionstoremove$ and $\newcells$): $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_{\ell=0}^{n}\\ \basis = \{F^A_\ell, F^D_\ell\}_{\ell=0}^{n-1}\\ \functionstoremove=\{\functionstoremove_\ell\}_{\ell=0}^{n-1}\\  \newcells = \{\newcells_\ell\}_{\ell=0}^n \end{cases}$}
%%  \KwResult{(Data for $\HH^*$):  $\basis = \{F^A_\ell, F^D_\ell\}_{\ell=0}^n$}
%% \medskip

%% \begin{enumerate}
%%  \item[1.] \lIf{ $\functionstoremove_{n-1}\neq \emptyset$,} {$F^A_n=F^D_n=\emptyset$}
%% \item[]\ForEach{$\ell=0,1,\dots,n-1$}{
%% \begin{enumerate}
%% \item[2.]$F^A_\ell \leftarrow F^A_\ell \setminus \functionstoremove_\ell$ \% Remove $\functionstoremove_\ell$ from the active functions of level $\ell$\;
%% \item[3.]$F^D_\ell\leftarrow F^D_\ell\cup \functionstoremove_\ell$ \% Update $F^D_\ell$ by adding the functions to be deactivated\;
%% \item[4.] $F^C \leftarrow$ \texttt{split\_fun} $(\functionstoremove_\ell)$, \% Compute the list of children functions of the marked functions;
%% \item[5.] $F^C \leftarrow F^C \setminus (F^A_{\ell+1} \cup F^D_{\ell+1})$ Take only the children that have not been already activated.
%%  \item[6.] $F^A_{\ell+1}\leftarrow F^A_{\ell+1}\cup F^C$ \% Enlarge $F^A_{\ell+1}$ by adding the new active functions\;
%%  \item[7.] Use \texttt{get\_cells} to update $\functionstoremove_{\ell+1}$ by adding the functions in $F^C$ that have no active cell of level $\ell+1$ within its support.

%% \end{enumerate}
%% }
%% \end{enumerate}
%% \medskip
%% }%\end{center}
%% \end{minipage}
%% }
%% \end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage

\begin{algorithm}
\caption{Update\_active\_functions: standard hierarchical space}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\mesh, \basis, \{\functionstoremove\} \{\newcells\}$
\For {$\ell = 0, \ldots, n-1$}
  \State $\activefunctions{\ell}\gets \activefunctions{\ell} \setminus \functionstoremove_\ell$
  \State $\deactfunctions{\ell}\gets \deactfunctions{\ell} \cup \functionstoremove_\ell$
  \State $\tt{F^C} \gets \textbf{get\_basis\_functions} \, (\newcells_{\ell+1})$
  \State $\tt{F^C} \gets \tt{F^C} \setminus \activefunctions{\ell+1}$
  \State {\Rd Use \texttt{get\_cells} to update $\tt{F^C}$ by removing the functions such that have at least one cell of level $\ell+1$ in their support that does not belong to $\activeelements{\ell+1}\cup \deactelements{\ell+1}$\;}
  \State $\activefunctions{\ell+1} \gets \activefunctions{\ell+1} \cup \tt{F^C}$
\EndFor
\Statex \textbf{Output:} ${\Rd \texttt{REFINED}\_\basis (\{\activefunctions{ }\}, \{\deactfunctions{} \})}$
\end{algorithmic}
\end{algorithm}

%% \begin{algorithm}[H]{$\texttt{function}\quad \basis = \texttt{update\_active\_functions}(\mesh,\basis,\functionstoremove,\newcells)$\;} 
%% \caption{\texttt{update\_active\_functions}}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% %\begin{center}
%% \medskip
%% {%\footnotesize
%% \% This function updates the active and deactivated B-spline basis functions, {\Rd when using the standard hierarchical space}. The inputs $\mesh$ and $\newcells$ are already updated (see \texttt{refine\_hierarchical\_mesh}) and $\functionstoremove$ contains the indices of \emph{all B-splines that have to be deactivated} (see \texttt{compute\_functions\_to\_deactivate}). Finally, the variable $\basis$ in the input contains the information before updating the space\,

%% \KwData{(Data for $\QQ^*$, $\HH$, $\functionstoremove$ and $\newcells$): $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_{\ell=0}^{n}\\ \basis = \{F^A_\ell, F^D_\ell\}_{\ell=0}^{n-1}\\ \functionstoremove=\{\functionstoremove_\ell\}_{\ell=0}^{n-1}\\  \newcells = \{\newcells_\ell\}_{\ell=0}^n \end{cases}$}
%%  \KwResult{(Data for $\HH^*$):  $\basis = \{F^A_\ell, F^D_\ell\}_{\ell=0}^n$}
%% \medskip

%% \begin{enumerate}
%%  \item[1.] \lIf{ $\newcells_{n-1}\neq \emptyset$,} {$F^A_n=F^D_n=\emptyset$}
%% \item[]\ForEach{$\ell=0,1,\dots,n-1$}{
%% \begin{enumerate}
%% \item[2.]$F^A_\ell \leftarrow F^A_\ell \setminus \functionstoremove_\ell$ \% Remove $\functionstoremove_\ell$ from the active functions of level $\ell$\;
%% \item[3.]$F^D_\ell\leftarrow F^D_\ell\cup \functionstoremove_\ell$ \% Update $F^D_\ell$ by adding the functions to be deactivated\;
%% \item[4.] $F^C \leftarrow$\texttt{get\_basis\_functions($\newcells_{\ell+1}$)} \% Compute the indices of B-splines of level $\ell+1$ that do not vanish in some cell of $\newcells_{\ell+1}$\;
%% \item[5.] $F^C \leftarrow F^C \setminus F^A_{\ell+1}$ \% Remove from $F^C$ the functions that were already active\;
%% \item[6.] Use \texttt{get\_cells} to update $F^C$ by removing the functions such that have at least one cell of level $\ell+1$ in their support that does not belong to $E^A_{\ell+1}\cup E^D_{\ell+1}$\;
%% \item[7.] $F^A_{\ell+1}\leftarrow F^A_{\ell+1}\cup F^C$\;
%% \end{enumerate}
%% }
%% \end{enumerate}
%% \medskip
%% }%\end{center}
%% \end{minipage}
%% }
%% \end{algorithm}

%\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Refinement matrix between hierarchical spaces (knot insertion)}
Since the spaces are nested, $\Span\HH \subset \Span\HH^*$, we can write a function in the first space as a linear combination of basis functions in the second one, and the operation can be done through a matrix. It is possible to use the information of active and deactivated functions to obtain this. 

{\Rd MORE NOTATION TO BE FIXED
\begin{itemize}
\item $N_\ell$: number of basis functions for the tensor-product space of level $\ell$.
\item $N^A_\ell$: number of active functions of level $\ell$ in the hierarchical space.
\item $N^{A\cup D}_\ell$: number of active and deactivated functions of level $\ell$.
\end{itemize}
The analogous notation with $*$ is used for the refined space.
}

Since any (active) function in $\HH$ is either in $\HH^*$ or in the set of deactivated functions {\Rd (DEFINE)}, we can define the rectangular matrix $\tilde I_\ell \in {\cal M}_{N^{*^{A\cup D}}_{\ell}, N^A_\ell}$ such that 
\begin{equation*}
(\tilde I_\ell)_{ij} = \left \{ 
\begin{array}{l}
1, \text{ if }  \beta^{*^{A \cup D}}_{i,\ell} = \beta^A_{j,\ell} (active)\\
0, \text{ otherwise. }
\end{array}
\right.
\end{equation*}

We define the matrix for refinement $K = K_n$ with the following recursive algorithm:
\begin{enumerate}
\item $K_0 = \tilde I_0$,
\item $K_{\ell+1} = \left [ 
\begin{array}{cc}
K^{A^*}_\ell & 0 \\
K_\ell^{\ell+1} K^{D^*}_\ell & \tilde I_{\ell+1}
\end{array}
\right]$,
\end{enumerate}
where $K_\ell^{A^*}$ and $K_\ell^{D^*}$ are submatrices of $K_\ell$ restricted to the rows corresponding to {\Rd active and deactivated functions in $\HH^*$. The matrix $K_\ell^{\ell+1}$ is the submatrix of $C_\ell^{\ell+1}$ restricted to the rows of active and deactivated functions of level $\ell+1$ in $\HH^*$, and the columns of deactivated functions of level $\ell$ in $\HH^*$. }

We remark that this recursive algorithm is independent of the chosen hierarchical space (either standard or simplified). To compute the same matrix for truncated hierachical B-splines, one only needs to replace the matrix $C_\ell^{\ell+1}$ (and its submatrix) by its truncated version. {\Rd (EXPLAIN IN PREVIOUS SECTIONS)}

The refinement matrix $K$ may become useful in several occasions. For instance, it can be used for applying knot insertion; in time dependent problems, it can serve to pass the solution from the previous time step to the current mesh; in multigrid methods, it can be used to pass from a grid of $n$ levels to a grid of $n+1$ levels...

\subsection{Initialization of a hierarchical spline space}

The function \texttt{refine} detailed in the previous section can be also used to select the active functions of a hierarchical B-spline basis $\HH$, if we know the active cells of each level~$\{E^A_\ell\}_{\ell=0}^{n-1}$. 

\begin{algorithm}
\caption{build\_hierarchical\_space}
\begin{algorithmic}[1]
\Statex \textbf{Input:} $\{\activeelements{ }\}$
\State $\mesh \gets \textbf{mesh\_cartesian}$  \Comment{Initialize as a Cartesian grid of level 0}
\State $\basis \gets \textbf{spline\_space}$  \Comment{Initialize as a tensor product space of level 0}
\For {$\ell = 0, n-2$}
  \State $\{\marked\}_0^{\ell-1} \gets \emptyset$
  \State $\marked_\ell \gets \tt{\hat E^A_\ell} \setminus \activeelements{\ell}$
  \State $[\mesh, \basis] \gets \textbf{refine} \, (\mesh, \basis, \marked)$
\EndFor
\Statex \textbf{Output:}
\end{algorithmic}
\end{algorithm}

%% \begin{algorithm}[H]{$\texttt{function}\quad [\mesh,\basis] = \texttt{build\_hierarchical\_space}(\{E^A_\ell\}_{\ell=0}^{n-1})$} 
%% \caption{$\texttt{build\_hierarchical\_space}$}
%% \bigskip
%% \doublebox{
%% \begin{minipage}{.95\textwidth}
%% \medskip

%% \KwData{$\{E^A_\ell\}_{\ell=0}^{n-1}$ (Active elements in each level)}
%%  \KwResult{(Data for $\QQ$ and $\HH$):  $\begin{cases}\mesh = \{E^A_\ell,E^D_\ell\}_\ell\\ \basis = \{F^A_\ell, F^D_\ell, W_\ell\}_\ell \end{cases}\,\, (\ell=0,1,\dots,n-1).$}
%% \medskip

%% \begin{enumerate}
%%  \item[1.] Define $\hat{E}^A_0$ as the set of indices of all the cells in $\QQ_0$\;
%%  \item[2.] Define $F^A_0$ as the set of indices of all the basis functions in $\BB_0$\;

%% \item[3.] Define the corresponding array of weights $W_0$ setting all the values equal to $1$\;
%% \item[4.] $\hat{E}^D_0=\emptyset$\;
%% \item[5.] $F^D_0=\emptyset$\;
%% \item[6.] $\mesh=\{\hat{E}^A_0,\hat{E}^D_0\}$\; 
%% \item[7.] $\basis=\{F^A_0,F^D_0,W_0\}$\;
%% \item[] \ForEach{$k = 0,\dots,n-2$}{
%% \begin{enumerate}
%%  \item[8.] Let $M_0 =\dots = M_{k-1}=\emptyset$ and $M_{k} = \hat{E}^A_k\setminus E^A_k$. Then, $\marked=\{M_\ell\}_{\ell=0}^k$\;
%%  \item[9.] $[\mesh,\basis]\,=\,\texttt{refine}(\mesh,\basis,\marked)$\;
%% \end{enumerate}
%%  }
%% \end{enumerate}









%% \medskip
%% \end{minipage}
%% }
%% \end{algorithm}



\begin{remark}
 In order to make the last algorithm more understandable we have used the function $\verb+refine+$. This algorithm can be improved by adapting the code of $\verb+refine+$ instead of call it. Notice that the set of marked cells in each of the calls to $\verb+refine+$ has cells only of one level. 
\end{remark}


%\note{ $C_\ell$ is a connectivity matrix which cointains the global indices of active functions whose support intersect $Q$, for every $Q\in\QQ\cap\QQ_\ell$. Here, we also need to store the corresponding levels together with the global indices of active functions.}

\section{Assembly of the matrix}
{\Rd SOME NOTATION, to be changed after discussion:
\begin{itemize}
\item $N_\ell$: number of basis functions in $\BB_\ell$.
\item $N^A_\ell$: number of active functions of level $\ell$. Give a name to the sets in \eqref{E:Hierarchical basis}.
\item $\tilde N^A_\ell := \sum_{k=0}^\ell N^A_k$, number of active functions up to level $\ell$.
\item $\beta^A_{j,\ell}$ active functions. Probably we can avoid these.
\end{itemize}
}

One of the issues when implementing IGA with hierarchical splines is the assembly of the matrices. In order to compute the matrices of the discrete problem it is necessary to evaluate integrals that involve basis functions from different levels, and possibly in a level that does not correspond to the level of the functions. For instance, to compute one entry of the mass matrix, one must compute
\begin{equation*}
\int_\Omega \beta_{i,\ell_i} \beta_{j,\ell_j} \, d\bx = \sum_{Q \in \QQ} \int_Q \beta_{i,\ell_i} \beta_{j,\ell_j} \, d\bx = \sum_{\ell = \max\{\ell_i, \ell_j\}}^n \sum_{Q_\ell \in \QQ_\ell} \int_{Q_\ell} \beta_{i,\ell_i} \beta_{j,\ell_j} \, d\bx.
\end{equation*}

In order to compute the integrals, we take advantage of the two-scale relation \eqref{E:two scale relation}: {\Rd I AM CHANGING THE NOTATION}
\begin{equation*}
 \beta_{i,\ell} = \sum_{k=1}^{N_{\ell+1}}
c_{k,\ell+1}(\beta_{i,\ell})\beta_{k,\ell+1}, 
\qquad \forall\,\beta_{i,\ell} \in\BB_\ell,
\end{equation*}
and computing the coefficients for each basis function, we obtain an operator $C_\ell^{\ell+1}: \VV_\ell \longrightarrow \VV_{\ell+1}$, which can be written in matrix form.

Succesively applying the two-scale relation, we obtain the general version
\begin{equation*}
 \beta_{i,\ell} = \sum_{k=1}^{N_{\ell+m}}
c_{k,\ell+m}(\beta_{i,\ell})\beta_{k,\ell+m}, 
\qquad \forall\,\beta_{i,\ell} \in\BB_\ell,
\end{equation*}
and the matrix operator $C_\ell^{\ell+m} = C_{\ell+m-1}^{\ell+m} \ldots C_{\ell+1}^{\ell+2} C_\ell^{\ell+1}$.

Plugging this expression into our integral, and after reordering, we obtain that 
\begin{align*}
\int_\Omega \beta_{i,\ell_i} \beta_{j,\ell_j} \, d\bx = \sum_{\ell = \max\{\ell_i, \ell_j\}}^n \sum_{Q_\ell \in \QQ_\ell}  \int_{Q_\ell} \left(\sum_{k_i=1}^{N_\ell} c_{k_i,\ell}(\beta_{i,\ell_i}) \beta_{k_i,\ell}\right) \left(\sum_{k_j=1}^{N_\ell} c_{k_j,\ell}(\beta_{j,\ell_j}) \beta_{k_j,\ell}\right) \, d\bx = \\
\sum_{\ell = \max\{\ell_i, \ell_j\}}^n \sum_{k_i=1}^{N_\ell} \sum_{k_j=1}^{N_\ell} c_{k_i,\ell}(\beta_{i,\ell_i}) c_{k_j,\ell}(\beta_{j,\ell_j}) \sum_{Q_\ell \in \QQ_\ell}  \int_{Q_\ell}  \beta_{k_i,\ell}  \beta_{k_j,\ell} \, d\bx.
\end{align*}

After the arrangements, we see that it is only needed to compute, in the active elements of level $\ell$, the integrals involving the tensor product functions of that level, both active and inactive. The computation of these integrals is easily available in any software for IGA. 

The only missing part is the computation of the coefficients in an efficient way. This can be done rewriting the equations in matrix form. Let us denote by $M_\ell$ the matrix obtained from function of level $\ell$, that is
\begin{equation*}
(M_\ell)_{k_i k_j} = \sum_{Q_\ell \in \QQ_\ell}  \int_{Q_\ell}  \beta_{k_i,\ell}  \beta_{k_j,\ell} \, d\bx,
\end{equation*}
and let us also denote by $\tilde I_\ell \in {\cal M}_{N_\ell, N^A_\ell}$ the rectangular matrix such that 
$$
(\tilde I_\ell)_{ij} = \left \{ 
\begin{array}{l}
1, \text{ if }  \beta_{i,\ell} = \beta^A_{j,\ell} (active)\\
0, \text{ otherwise. }
\end{array}
\right.$$

We define the matrices for basis change $C_\ell \in {\cal M}_{N_\ell, \tilde N^A_\ell}$ by the recursive algorithm
\begin{enumerate}
\item $C_0 = \tilde I_0$.
\item $C_\ell = [C_{\ell-1}^\ell C_{\ell-1}, \tilde I_\ell]$.
\end{enumerate}

By doing so, the global mass matrix is written as
\begin{equation*}
M = \sum_{\ell = 0}^n C^T_\ell M_\ell C_\ell.
\end{equation*}


\bibliographystyle{siam}
\bibliography{biblio}

%===============================================================================
%\begin{thebibliography}{1}
%===============================================================================
%\bibitem[BG15a]{BG15}
%A. Buffa and E.M. Garau, \emph{New refinable spaces and local approximation estimates for hierarchical splines}, submitted, 2015.

%\bibitem[BG15b]{BuGa15}
%A. Buffa and E.M. Garau, \emph{A posteriori error estimators for hierarchical B-spline discretizations}, in preparation, 2015.

% 
% \bibitem[BG15]{BG15}
% A. Buffa and C.~Giannelli, \emph{Adaptive isogemetric techniques via hierarchical splines: error 
% estimator and convergence}, submitted, 2015.
% 
% \bibitem[CKNS08]{CKNS08}
% J.M. Cascon, C. Kreuzer, R.H. Nochetto and K.G. Siebert, \emph{Quasi-optimal convergence rate for an adaptive finite element method}, SIAM J. Numer. Anal. 46 (2008), no. 5, 2524--2550. 
% 
% \bibitem[CW96]{Chua-Wheeden}
% S.-K. Chua and R. L. Wheeden, \emph{Estimates of best constants for weighted 
% Poincar\'e inequalities on convex domains}, Proceedings of LMS \textbf{93} 
% (2006), 197--226.

%\bibitem[dB01]{deBoor}
%C. de Boor, \emph{A practical guide to splines}, Revised edition. Applied Mathematical Sciences, 27. Springer-Verlag, New York, 2001. 

%\bibitem[GJS14]{GJS14}
%C. Giannelli, B. J\"uttler, and H. Speleers, \emph{Strongly stable bases for adaptively refined multilevel spline spaces}, Adv. Comput. Math. 40 (2014), no. 2, 459--490.

% \bibitem[K97]{Kraft}
% R. Kraft, \emph{Hierarchical B-splines}, Preprint of Math. Inst. A Uni.Stuttgart.

%\bibitem[K98]{Kraft-thesis}
%R. Kraft, \emph{Adaptive und linear unabh\"angige multilevel B-Splines und ihre Anwendungen}, Ph.D. thesis, Universit\"at Stuttgart, 1998. 

% 
% \bibitem[MSV08]{MSV-convergence}
% P.~Morin, K.G.~Siebert and A.~Veeser, \emph{A basic convergence
%   result for conforming adaptive finite elements}, Math. Models Methods Appl.
%   Sci. \textbf{18} (2008), no.~5, 707--737.
% 
% 
% \bibitem[NV]{Nochetto-Veeser}
% R.H. Nochetto and A. Veeser, \emph{Primer of adaptive finite element 
% methods}, Multiscale and Adaptivity: Modeling, Numerics and Applications, CIME 
% Lectures, eds R. Naldi and G. Russo, Springer (to appear).

%\bibitem[S07]{Schumaker}
%L.L. Schumaker, \emph{Spline functions: basic theory}, Third edition, Cambridge Mathematical Library, Cambridge University Press, Cambridge, 2007.

% 
% \bibitem[S11]{S11}
% K.G.~Siebert, \emph{A convergence proof for adaptive finite elements without lower bound}, IMA J. Numer. Anal. 31 (2011), no. 3, 947--970. 

% \bibitem[SM14]{SM14}
% H. Speleers and C. Manni, \emph{Effortless quasi-interpolation in hierarchical spaces}, Preprint, 2014.
% 
% \bibitem[VV09]{Veeser-Verfurth}
% A. Veeser and R. Verf\"urth, \emph{Explicit upper bounds for dual norms of 
% residuals}, SIAM J. Numer. Anal. 47 (2009), no. 3, 2387--2405.


%\bibitem[VGJS11]{Vuong etal}
%A.-V. Vuong, C. Giannelli, B. J\"uttler and B. Simeon, \emph{A hierarchical approach to adaptive local refinement in isogeometric analysis}, Comput. Methods Appl. Mech. Engrg. 200 (2011), no. 49-52, 3554--3567.


%\end{thebibliography}




\end{document}
